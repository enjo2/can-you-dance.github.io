<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Trust Me ‚Äî Doodle & Panda Dance</title>
  <style>
    :root {
      --bg: #f6f7fb;
      --card: #fff;
      --text: #1f2d3d;
      --accent: #2e7d32;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto; background: var(--bg); color: var(--text); }
    .container {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 2rem;
    }
    .card {
      width: min(900px, 92vw);
      background: var(--card);
      border-radius: 20px;
      padding: 28px;
      box-shadow: 0 10px 25px rgba(0,0,0,.08);
      text-align: center;
    }
    .title {
      font-size: 1.4rem;
      margin-bottom: 0.5rem;
    }
    #trustBtn {
      padding: 14px 26px;
      font-size: 1.05rem;
      border: none;
      border-radius: 999px;
      background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%);
      color: white;
      cursor: pointer;
      box-shadow: 0 6px 14px rgba(46,125,50,.4);
      transition: transform .2s ease;
    }
    #trustBtn:active { transform: scale(0.98); }
    #content { display: none; margin-top: 1rem; }
    .stage {
      display: grid;
      gap: 20px;
      justify-items: center;
    }
    /* Doodle canvas */
    #doodle {
      width: 100%;
      max-width: 640px;
      height: 320px;
      border-radius: 12px;
      border: 1px solid #ddd;
      background: #fff;
      display: block;
    }
    /* Panda dancing (emoji-based) */
    .pandaWrap { margin-top: 6px; }
    .panda {
      font-size: clamp(72px, 18vw, 120px);
      display: inline-block;
      transform-origin: center;
    }
    /* Simple dancing animation for the panda emoji */
    @keyframes pandaDance {
      0%   { transform: rotate(0deg); translateX(0); }
      25%  { transform: rotate(-8deg) translateX(-6px); }
      50%  { transform: rotate(0deg) translateX(0); }
      75%  { transform: rotate(8deg) translateX(6px); }
      100% { transform: rotate(0deg) translateX(0); }
    }
    .dance { animation: pandaDance 0.8s ease-in-out infinite; }
    /* Optional hint cursor for drawing */
    canvas.drawing { cursor: crosshair; }
  </style>
</head>
<body>
  <div class="container">
    <section class="card" aria-label="Trust me to start a doodle and a dancing panda">
      <div class="title">Trust me to start a doodle and a baby panda dancing</div>
      <button id="trustBtn" aria-label="Trust me">Trust me</button>

      <div id="content" aria-label="Doodle canvas and panda dancing">
        <div class="stage">
          <canvas id="doodle" width="640" height="320" class="drawing" aria-label="Doodle canvas"></canvas>
          <div class="pandaWrap" aria-label="Baby panda dancing">
            <span id="panda" class="panda" role="img" aria-label="Baby panda dancing">üêº</span>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    // Elements
    const trustBtn = document.getElementById('trustBtn');
    const content = document.getElementById('content');
    const panda = document.getElementById('panda');
    const canvas = document.getElementById('doodle');
    const ctx = canvas.getContext('2d');

    // Doodle state
    let drawing = false;
    let lastX = 0, lastY = 0;
    let autoDoodleTimer = null;

    // Helpers
    function randomColor() {
      const colors = ['#e74c3c', '#f1c40f', '#2ecc71', '#3498db', '#9b59b6', '#e67e22', '#2c3e50'];
      return colors[Math.floor(Math.random() * colors.length)];
    }

    // Auto doodle: draw random short lines to simulate "doodling"
    function autoDoodle() {
      if (!ctx) return;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = randomColor();
      ctx.lineWidth = 2 + Math.random() * 2;
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      const x2 = Math.min(canvas.width, Math.max(0, x + (Math.random() * 60 - 30)));
      const y2 = Math.min(canvas.height, Math.max(0, y + (Math.random() * 60 - 30)));
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    // Start auto doodling for a short duration
    function startDoodleAuto(durationMs = 5000, intervalMs = 60) {
      // Clear previous doodles
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (autoDoodleTimer) clearInterval(autoDoodleTimer);
      autoDoodleTimer = setInterval(autoDoodle, intervalMs);
      setTimeout(() => {
        clearInterval(autoDoodleTimer);
        autoDoodleTimer = null;
      }, durationMs);
    }

    // User doodling handlers
    function onMouseDown(e) {
      drawing = true;
      const rect = canvas.getBoundingClientRect();
      lastX = e.clientX - rect.left;
      lastY = e.clientY - rect.top;
    }
    function onMouseMove(e) {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      ctx.strokeStyle = '#2c7';
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(x, y);
      ctx.stroke();
      lastX = x;
      lastY = y;
    }
    function onMouseUp() {
      drawing = false;
    }

    // Touch events for mobile
    function onTouchStart(e) {
      if (!e.touches.length) return;
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      lastX = t.clientX - rect.left;
      lastY = t.clientY - rect.top;
      drawing = true;
      e.preventDefault();
    }
    function onTouchMove(e) {
      if (!drawing || !e.touches.length) return;
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = t.clientX - rect.left;
      const y = t.touches[0].clientY - rect.top;
      // Correct vertical/horizontal values
      ctx.strokeStyle = '#2c7';
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(x, y);
      ctx.stroke();
      lastX = x;
      lastY = y;
      e.preventDefault();
    }
    function onTouchEnd(e) {
      drawing = false;
      e.preventDefault();
    }

    // Initialize: reveal content, start panda dance, and doodle
    trustBtn.addEventListener('click', () => {
      trustBtn.style.display = 'none';
      content.style.display = 'block';
      // Start panda dancing
      panda.classList.add('dance');
      // Start auto doodling
      startDoodleAuto();
      // Enable user doodling
      enableUserDoodle();
    });

    function enableUserDoodle() {
      // Mouse
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
      // Touch
      canvas.addEventListener('touchstart', onTouchStart, { passive: false });
      canvas.addEventListener('touchmove', onTouchMove, { passive: false });
      canvas.addEventListener('touchend', onTouchEnd, { passive: false });
    }

    // Optional: ensure the canvas is clear on load
    (function initCanvas() {
      if (canvas && ctx) {
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    })();
  </script>
</body>
</html>
